require 'cupoftea'
require './assertions.jungle'

parse = require './parser.jungle': parse

assume ?term is module with statements ?action =
    if (term: is module)
        action (term: statements)
    else
        throw (new (Error ('expected module, but found ' + @term)))

assume ?statements has just one statement ?action =
    if ((statements: statements: length) == 1)
        action (statements: statements: 0)
    else
        throw (new (Error ('expected statements to have just one statement, found ' + (statements: statements: length))))

expression ?source =
    term = parse @source
    assume @term is module with statements ?statements
        assume @statements has just one statement ?s
            s

spec 'parser'
    spec 'terminals'
        spec 'integer'
            (expression '5') should contain fields #
                integer 5

        spec 'float'
            (expression '5.6') should contain fields #
                float 5.6

        spec 'variable'
            (expression 'total weight') should contain fields #
                variable ['total', 'weight']

    spec 'function calls'
        spec 'function call'
            (expression 'touch @file') should contain fields #
                function #{variable ['touch']}
                arguments [#{variable ['file']}]

        spec 'function call with no argument'
            (expression 'delete everything!') should contain fields #
                function #{variable ['delete', 'everything']}
                arguments []

        spec 'function call with block with parameters'
            (expression 'with file @file ?stream {stream}') should contain fields #
                function #{variable ['with', 'file']}
                arguments [
                    #{variable ['file']}
                    #
                        body #{statements [#{variable ['stream']}]}
                        parameters [#{parameter ['stream']}]
                ]

        spec 'function call with two blocks with parameters'
            (expression 'name ?x {x} ?y {y}') should contain fields #
                function #{variable ['name']}
                arguments [
                    #
                        body #{statements [#{variable ['x']}]}
                        parameters [#{parameter ['x']}]

                    #
                        body #{statements [#{variable ['y']}]}
                        parameters [#{parameter ['y']}]
                ]
    
    spec 'object operations'
        spec 'method call'
            (expression 'object: method @argument') should contain fields #
                is method call
                object #{variable ['object']}
                name ['method']
                arguments [#{variable ['argument']}]
        
        spec 'field reference'
            (expression 'object: field') should contain fields #
                is field reference
                object #{variable ['object']}
                name ['field']
        
        spec 'indexer'
            (expression 'object: @x') should contain fields #
                is indexer
                object #{variable ['object']}
                indexer #{variable ['x']}

    spec 'blocks'
        spec 'block'
            (expression '{x.y}') should contain fields #
                is block
                parameters []
                body #{statements [
                    #{variable ['x']}
                    #{variable ['y']}
                ]}

        spec 'block with parameter'
            (expression '?x {x.y}') should contain fields #
                is block
                parameters [#{parameter ['x']}]
                body #
                    statements [
                        #{variable ['x']}
                        #{variable ['y']}
                    ]

    spec 'assignment'
        spec 'assignment'
            (expression 'x = y') should contain fields #
                is definition
                target #{variable ['x']}
                source #{variable ['y']}

        spec 'field assignment'
            (expression 'o: x = y') should contain fields #
                is definition
                target #
                    is field reference
                    object #{variable ['o']}
                    name ['x']

                source #{variable ['y']}

        spec 'index assignment'
            (expression 'o: @x = y') should contain fields #
                is definition
                target #
                    is indexer
                    object #{variable ['o']}
                    indexer #{variable ['x']}

                source #{variable ['y']}

        spec 'assignment from field'
            (expression 'x = y: z') should contain fields #
                is definition
                target #{variable ['x']}
                source #
                    is field reference
                    object #
                        variable ['y']

                    name ['z']
